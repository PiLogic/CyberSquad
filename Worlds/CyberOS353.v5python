{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nexpander_4 = Triport(Ports.PORT4)\nL1 = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nL2 = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nL3 = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nR1 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, True)\nR2 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\nR3 = Motor(Ports.PORT9, GearSetting.RATIO_6_1, True)\ncontroller_1 = Controller(PRIMARY)\nMogo = DigitalOut(brain.three_wire_port.h)\nBelt = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nLoader = Motor(Ports.PORT17, GearSetting.RATIO_18_1, True)\nlifter = DigitalOut(expander_4.a)\nArm = DigitalOut(expander_4.c)\nWallStakeMotor = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nWallStakePos = PotentiometerV2(brain.three_wire_port.a)\nAutonSelector = PotentiometerV2(brain.three_wire_port.b)\nColourSensor = Optical(Ports.PORT19)\nDistanceSensor = Distance(Ports.PORT10)\nInertialSensor = Inertial(Ports.PORT18)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nimport time \n\nSpeedLeft = 0\nSpeedRight = 0\nSpeedMultiplier = 1\nWheelDiameter = 82.55\nWheelBaseWidth = 254\nPi = 3.1415\nkp = 0.12\nki = 0.0\nkd = 0.15\nLeftMotors = [L1,L2,L3]\nRightMotors = [R1,R2,R3]\nDriveMotors = LeftMotors + RightMotors\nSelectedAuton = 1\nAvoidBlue = True\narmEnabled = False\nlifterEnabled = False\nloaderEnabled = False\nwallStakeLoading = False\nbeltChecker = False\nLastAuton = ''\n\ndef pause(sec):\n    wait(sec,SECONDS)\n\ndef PIDControl(target, isTurning=False, reverse = False):\n    error = 0\n    integral = 0\n    lastError = 0\n\n    if isTurning:\n        kp = 0.35\n        kd = 1\n        threshold = 1\n    else:\n        kp = 0.1\n        kd = 0.6\n        threshold = 0.45\n\n    for motor in DriveMotors:\n        motor.reset_position()\n    count = 150\n    while True and count > 0:\n        if isTurning:\n            current = InertialSensor.heading() \n            print(current)\n            error = (target-current+540)%360-180   \n        else:\n            leftPos = sum([m.position(DEGREES) for m in [L1, L2, L3]]) / 3\n            rightPos = sum([m.position(DEGREES) for m in [R1, R2, R3]]) / 3\n            current = (abs(leftPos) + abs(rightPos)) / 2  \n            error = target-current         \n\n        integral += error\n        derivative = error - lastError\n\n        power = (kp * error) + (ki * integral) + (kd * derivative)\n        power = max(min(power, 100), -100)\n        power *= SpeedMultiplier\n        if isTurning:\n            if power < 0:\n                power = abs(power)\n                for motor in LeftMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n            else:\n                for motor in LeftMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n        else:\n            for motor in DriveMotors:\n                if reverse:\n                    motor.spin(REVERSE, power, PERCENT)\n                else:\n                    motor.spin(FORWARD,power,PERCENT)\n\n        if abs(error) < threshold:\n            break\n\n        lastError = error\n        count -= 1\n        wait(20, MSEC)\n\n\n    for motor in DriveMotors:\n        motor.stop()\n    if count == 0:\n        print('Didn\\'t reach target')\n\ndef distanceToDegrees(dist):\n    degrees = (dist / (WheelDiameter * Pi)) * 360\n    degrees *= (4/3)\n    return degrees\n\ndef forward(dist):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees)\n\ndef backward(dist):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees,reverse = True)\n\ndef turnTo(target):\n    target = target % 360\n    for _ in range(2):\n        PIDControl(target, isTurning=True)\n    print(InertialSensor.heading(DEGREES))\n\ndef display(row,message):\n    brain.screen.set_cursor(row,6)\n    brain.screen.clear_row(row)\n    brain.screen.print(message)\n    \n\ndef RedLeft():\n    display(7,'Red Left Starting')\n    turnTo(90)\n    turnTo(180)\n    turnTo(270)\n    turnTo(360)\n\ndef RedRight():\n    display(7,'Red Right Starting')\n    InertialSensor.set_heading(270,DEGREES)\n    turnTo(234)\n    WallStakeTo(1000)\n    WallStakeLow()\n    pause(3)\n    turnTo(284)\n    LiftLifter()\n    forward(200)\n    backward(100)\n    LowerLifter()\n    turnTo(197)\n    backward(700)\n    clampMogo()\n    backward(100)\n    turnTo(90)\n    forward(500)\n\n    \ndef BlueLeft():\n    display(7,'Blue Left Starting')\n    forward(700)\n    clampMogo()\n    startIntake()\n\ndef BlueRight():\n    display(7,'Blue Right Starting')\n    forward(700)\n    clampMogo()\n    startIntake()\n\ndef Autonomous():\n    global SpeedMultiplier\n    SpeedMultiplier = 0.6\n    for motor in  DriveMotors:\n        motor.set_stopping(HOLD)\n    \n    if SelectedAuton == 1:\n        RedLeft()\n    elif SelectedAuton == 2:\n        RedRight()\n    elif SelectedAuton == 3:\n        BlueLeft()\n    else:\n        BlueRight()\n\ndef Driver():\n    global SpeedMultiplier\n    SpeedMultiplier = 1\n    for motor in DriveMotors:\n        motor.set_stopping(COAST)\n\ndef CalibrateWallStake():\n    p = WallStakePos.angle(PERCENT)\n    d = (-0.0222)*p*p+(18.27)*p-561.54\n    WallStakeMotor.set_position(d,DEGREES)\n\ndef MotorTemp():\n    x = 0\n    for motor in DriveMotors:\n        message = str(x+1) + ': '+str(motor.temperature(PERCENT))\n        row = x//2+1\n        if x % 2 == 0:\n            val = 1\n            controller_1.screen.clear_row(row)\n        else:\n            val = 10\n        \n        controller_1.screen.set_cursor(row,val)\n        controller_1.screen.print(message)\n        \n        if x == 1:\n            controller_1.screen.set_cursor(1,20)\n            controller_1.screen.print(str(round(brain.battery.voltage(VOLT)/13*100)) + '%')\n        elif x == 3:\n            controller_1.screen.set_cursor(2,20)\n            controller_1.screen.print(NumberToCode(SelectedAuton))            \n        x += 1\n\ndef NumberToCode(Number):\n    if SelectedAuton == 1:\n        return 'RL'\n    elif SelectedAuton == 2:\n        return 'RR'\n    elif SelectedAuton == 3:\n        return 'BL'\n    else:\n        return 'BR'\n\ndef StartProcedure():\n    global SpeedLeft, SpeedRight\n    brain.screen.clear_screen()\n    brain.screen.print(\"T-VEX\")\n    brain.screen.next_row()\n    brain.screen.print(\"CyberSquad_78116A\")\n    brain.screen.next_row()\n    brain.screen.print(\"A Bajaj & Collis production\")\n    Belt.set_velocity(60, PERCENT)\n    Belt.set_max_torque(100,PERCENT)\n    Loader.set_velocity(100, PERCENT)\n    WallStakeMotor.set_velocity(150, PERCENT)\n    WallStakeMotor.set_stopping(HOLD)\n    CalibrateWallStake()\n    InertialCalibration()\n    StartTime = time.time()\n    TenSeconds = False\n    while True:\n        if not competition.is_autonomous() and not TenSeconds:\n            AutonChoosing()\n            if time.time() - StartTime >= 10:\n                TenSeconds = True\n                print('Auton Selector disabled')\n        if competition.is_driver_control():\n            SpeedLeft = (controller_1.axis3.position()) / 8.3\n            SpeedRight = (controller_1.axis2.position()) / 8.3\n            L1.spin(FORWARD, SpeedLeft, VOLT)\n            L2.spin(FORWARD, SpeedLeft, VOLT)\n            L3.spin(FORWARD, SpeedLeft, VOLT)\n            R1.spin(FORWARD, SpeedRight, VOLT)\n            R2.spin(FORWARD, SpeedRight, VOLT)\n            R3.spin(FORWARD, SpeedRight, VOLT)\n        wait(5,MSEC)\n    \ndef clampMogo():\n    Mogo.set(True)\n\ndef unclampMogo():\n    Mogo.set(False)\n    Belt.spin_for(REVERSE,20,DEGREES)\n\ndef LoaderToggle():\n    global loaderEnabled, beltChecker\n    if loaderEnabled:\n        Belt.stop()\n        Loader.spin(FORWARD)\n    else:\n        Loader.stop()\n    loaderEnabled = not(loaderEnabled)\n    beltChecker = False\n    \ndef startIntake():\n    global beltChecker\n    Belt.spin(FORWARD)\n    Loader.spin(FORWARD)\n    beltChecker = True\n\ndef reverseIntake():\n    global beltChecker\n    Belt.spin(REVERSE)\n    Loader.spin(REVERSE)\n    beltChecker = False\n\ndef stopIntake():\n    global beltChecker\n    Belt.stop()\n    Loader.stop()\n    beltChecker = False\n\ndef LiftLifter():\n\n    lifter.set(True)\n\ndef LowerLifter():\n    lifter.set(False)\n\ndef ToggleLifter():\n    global lifterEnabled\n    lifter.set(not(lifterEnabled))\n    lifterEnabled = not(lifterEnabled)\n\ndef LiftArm():\n    Arm.set(True)\n\ndef LowerArm():\n    Arm.set(False)\n\ndef ToggleArm():\n    global armEnabled\n    Arm.set(not(armEnabled))\n    armEnabled = not(armEnabled)\n\ndef WallStakeUp():\n    WallStakeMotor.spin(FORWARD)\n\ndef WallStakeDown():\n    WallStakeMotor.spin(REVERSE)\n\ndef WallStakeStop():\n    WallStakeMotor.stop()\n\ndef PlaceWallStake():\n    Belt.stop()\n    WallStakeTo(700)\n    WallStakeTo(300)\n\ndef WallStakePosition():\n    return int(WallStakeMotor.position(DEGREES))\n\ndef WallStakeTo(pos):\n    global wallStakeLoading\n    wallStakeLoading = False\n    WallStakeMotor.set_velocity(60,PERCENT)\n    val = WallStakePosition()\n    last = pos\n    count = 0\n    while abs(val-pos) > 5 and count < 2000:\n        if val > pos:\n            WallStakeDown()\n        else:\n            WallStakeUp()\n        if val == last:\n            count += 1\n        else:\n            count = 0\n        last = val\n        wait(0.1,MSEC)\n        val = WallStakePosition()\n        \n    WallStakeStop()\n    if count == 2000:\n        print('Wallstake didn\\'t reach target reaching',pos)\n    WallStakeMotor.set_velocity(60,PERCENT)\n\ndef WallStakeLow():\n    global beltChecker\n    WallStakeTo(0)\n    WallStakeMotor.set_position(0,DEGREES)\n    Belt.spin(FORWARD)\n    beltChecker = True\n\n\ndef WallStakeHigh():\n    global wallStakeLoading, beltChecker\n    WallStakeTo(110)\n    wallStakeLoading = True\n    beltChecker = False\n\ndef AutonChoosing():\n    global SelectedAuton, AvoidBlue, LastAuton\n    value = AutonSelector.angle(PERCENT)\n    if value <= 25:\n        SelectedAuton = 1\n    elif value <= 50:\n        SelectedAuton = 2\n    elif value <= 75:\n        SelectedAuton = 3\n    else:\n        SelectedAuton = 4\n    AvoidBlue = (SelectedAuton <= 2)\n    if SelectedAuton != LastAuton:\n        if SelectedAuton == 1:\n            display(6, 'Red Left Selected')\n        elif SelectedAuton == 2:\n            display(6, 'Red Right Selected')\n        elif SelectedAuton == 3:\n            display(6, 'Blue Left Selected')\n        else:\n            display(6, 'Blue Right Selected')\n        controller_1.screen.set_cursor(2,20)\n        controller_1.screen.print(NumberToCode(SelectedAuton))\n    LastAuton = SelectedAuton\n\ndef ColourSorting():\n    global AvoidBlue\n    ColourSensor.set_light(LedStateType.ON)\n    while True:\n        if AvoidBlue:\n            Avoid = Color.BLUE\n        else:\n            Avoid = Color.RED\n        if ColourSensor.color() == Avoid:\n            Belt.set_velocity(40,PERCENT)\n            previousPos = WallStakePosition()\n            if previousPos < 320:\n                concurrent = Thread(WallStakeLow)\n            pause(0.25)\n            while DistanceSensor.object_distance(MM) >= 25:\n                wait(2,MSEC)\n            Belt.spin_for(FORWARD, 120,DEGREES)\n            Belt.stop()\n            wait(20,MSEC)\n            Belt.set_velocity(60, PERCENT)\n            Belt.spin(FORWARD)\n            WallStakeTo(previousPos)\n        wait(10,MSEC)\n\ndef ObjectDetected():\n    if wallStakeLoading:\n        while DistanceSensor.object_distance(MM) >= 25:\n            wait(60,MSEC)\n        while Belt.velocity() > 0.1:\n            pause(1)\n        Belt.spin_for(REVERSE,20,DEGREES)\n        WallStakeTo(200)\n\ndef InertialCalibration():\n    InertialSensor.calibrate()\n    while InertialSensor.is_calibrating():\n        wait(100, MSEC)\n\ndef RunAuton():\n    autonTask = Thread(Autonomous)\n    while(competition.is_autonomous() and competition.is_enabled()):\n        wait(10, MSEC)\n    autonTask.stop()\n\ndef RunDriver():\n    driverTask = Thread(Driver)\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        wait( 10, MSEC )\n    driverTask.stop()\n\ndef DisplayTemp():\n    while True:\n        MotorTemp()\n        print('here')\n        pause(5)\n\ndef BeltUnstucker():\n    while True:\n        if beltChecker and Belt.velocity() < 0.1:\n            Belt.spin_for(REVERSE,50,DEGREES)\n            Belt.spin(FORWARD)\n        wait(10,MSEC)\n            \n\ncompetition = Competition( RunDriver, RunAuton )\n\ncontroller_1.buttonR1.pressed(clampMogo)\ncontroller_1.buttonR2.pressed(unclampMogo)\ncontroller_1.buttonL1.pressed(startIntake)\ncontroller_1.buttonL2.pressed(reverseIntake)\ncontroller_1.buttonL2.released(stopIntake)\ncontroller_1.buttonX.released(ToggleArm)\ncontroller_1.buttonY.released(ToggleLifter)\ncontroller_1.buttonA.released(PlaceWallStake)\ncontroller_1.buttonB.released(LoaderToggle)\ncontroller_1.buttonUp.released(WallStakeHigh)\ncontroller_1.buttonDown.released(WallStakeLow)\ncontroller_1.buttonLeft.pressed(WallStakeDown)\ncontroller_1.buttonLeft.released(WallStakeStop)\ncontroller_1.buttonRight.pressed(WallStakeUp)\ncontroller_1.buttonRight.released(WallStakeStop)\nColourSensor.object_detected(ObjectDetected)\nwait(15,MSEC)\n\nsimulRun1 = Thread(ColourSorting)\nsimulRun2 = Thread(DisplayTemp)\nsimulRun3 = Thread(BeltUnstucker)\nStartProcedure()","textLanguage":"python","robotConfig":[{"port":[1],"name":"L1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"L2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"R1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"R2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[9],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"Mogo","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[20],"name":"Belt","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"Loader","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"expander_4","customName":false,"deviceType":"Expander","deviceClass":"triport","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"lifter","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[3],"name":"Arm","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[5],"name":"WallStakeMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1],"name":"WallStakePos","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"AutonSelector","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{"id":"partner"},"triportSourcePort":22},{"port":[19],"name":"ColourSensor","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{"id":"partner"},"triportSourcePort":22},{"port":[10],"name":"DistanceSensor","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[18],"name":"InertialSensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}