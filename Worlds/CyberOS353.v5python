{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nexpander_4 = Triport(Ports.PORT4)\nL1 = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nL2 = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nL3 = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nR1 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, True)\nR2 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\nR3 = Motor(Ports.PORT9, GearSetting.RATIO_6_1, True)\ncontroller_1 = Controller(PRIMARY)\nMogo = DigitalOut(brain.three_wire_port.h)\nBelt = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nLoader = Motor(Ports.PORT17, GearSetting.RATIO_18_1, True)\nlifter = DigitalOut(expander_4.a)\nArm = DigitalOut(expander_4.c)\nWallStakeMotor = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nAutonSelector = PotentiometerV2(brain.three_wire_port.b)\nColourSensor = Optical(Ports.PORT19)\nDistanceSensor = Distance(Ports.PORT10)\nInertialSensor = Inertial(Ports.PORT18)\ncontroller_2 = Controller(PARTNER)\nResetButton = Bumper(expander_4.h)\nWallstakeRotation = Rotation(Ports.PORT15, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nimport time \n\nSpeedLeft = 0\nSpeedRight = 0\nSpeedMultiplier = 1\nWheelDiameter = 82.55\nWheelBaseWidth = 254\nPi = 3.1415\nkp = 0.12\nki = 0\nkd = 0.15\nLeftMotors = [L1,L2,L3]\nRightMotors = [R1,R2,R3]\nDriveMotors = LeftMotors + RightMotors\nSelectedAuton = 1\nAvoidBlue = True\narmEnabled = False\nlifterEnabled = False\nloaderEnabled = False\nwallStakeLoading = False\nbeltChecker = False\nLastAuton = ''\nColourSort = True\nButtonLoop = False\nAutonOptions = ['Red Left','Red Right','Blue Left','Blue Right','Red Ring Rush','Blue Ring Rush']\nAutonShort = ['RL','RR','BL','BR','RH','BH']\n\ndef pause(sec):\n    wait(sec,SECONDS)\n\ndef PIDControl(target, isTurning=False, reverse = False,slow=False):\n\n    if not slow:\n        highest = 100\n        lowest = -100\n    else:\n        highest = 25\n        lowest = -25\n\n    integral = 0\n    lastError = 0\n\n    if isTurning:\n        kp = 0.54\n        kd = 1.25\n        threshold = 1\n    else:\n        kp = 0.17\n        kd = 0.31\n        threshold = 3\n    error = threshold + 1\n\n    for motor in DriveMotors:\n        motor.reset_position()\n    count = 200\n    while count > 0 and abs(error) > threshold:\n        if isTurning:\n            current = InertialSensor.heading() \n            error = (target-current+540)%360-180\n        else:\n            leftPos = sum([m.position(DEGREES) for m in [L1, L2, L3]]) / 3\n            rightPos = sum([m.position(DEGREES) for m in [R1, R2, R3]]) / 3\n            current = (abs(leftPos) + abs(rightPos)) / 2  \n            error = target-current         \n\n        integral += error\n        derivative = error - lastError\n\n        power = (kp * error) + (ki * integral) + (kd * derivative)\n        power = max(min(power, highest), lowest)\n        power *= SpeedMultiplier\n        if isTurning:\n            if power < 0:\n                power = abs(power)\n                for motor in LeftMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n            else:\n                for motor in LeftMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n        else:\n             for motor in DriveMotors:\n                 if reverse:\n                     motor.spin(REVERSE, power, PERCENT)\n                 else:\n                     motor.spin(FORWARD,power,PERCENT)\n        count -= 1\n        lastError = error\n        \n        wait(10, MSEC)\n\n    print(current, target)\n    for motor in DriveMotors:\n        motor.stop()\n    if count == 0:\n        print('Didn\\'t reach target')\n\ndef distanceToDegrees(dist):\n    degrees = (dist / (WheelDiameter * Pi)) * 360\n    degrees *= (4/3)\n    return degrees\n\ndef FirstMotor(target):\n    L1.spin_for(FORWARD,target,DEGREES)\n\ndef SecondMotor(target):\n    L2.spin_for(FORWARD,target,DEGREES)\n\ndef ThirdMotor(target):\n    L3.spin_for(FORWARD,target,DEGREES)\n\ndef FourthMotor(target):\n    R1.spin_for(FORWARD,target,DEGREES)\n\ndef FifthMotor(target):\n    R2.spin_for(FORWARD,target,DEGREES)\n\ndef SixthMotor(target):\n    R3.spin_for(FORWARD,target,DEGREES)\n\ndef forward(dist, PID=False, slow=False):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees, slow=slow)\n\ndef backward(dist, slow=False):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees, reverse=True, slow=slow)\n\ndef turnTo(target,PID = False, slow = False):\n    target = target % 360\n    for _ in range(2):\n        PIDControl(target, isTurning=True, slow = slow)\n       \n    print(InertialSensor.heading(DEGREES))\n\ndef display(row,message):\n    brain.screen.set_cursor(row,6)\n    brain.screen.clear_row(row)\n    brain.screen.print(message)\n\ndef ReturnWallstake():\n    while not(ResetButton.pressing()):\n        WallStakeMotor.spin(REVERSE)\n        wait(10,MSEC)\n    WallStakeMotor.stop()\n\ndef StoreRing():\n    global beltChecker\n    count = 0\n    Loader.spin(FORWARD)\n    while (DistanceSensor.object_distance(MM) > 65 or not(DistanceSensor.is_object_detected())) and count < 2000:\n        Belt.spin(FORWARD)\n        count += 1\n        wait(1,MSEC)\n    if count < 2000:\n        Loader.spin(REVERSE)\n    beltChecker = False\n\n    Belt.stop()\n\ndef DrivingIntoMogo():\n    turnTo(144)\n    backward(275)\n\ndef WallStakePrep():\n    WallStakeTo(500)\n\ndef SetWallstake(val):\n    WallstakeRotation.set_position(val/5, DEGREES)\n\ndef RedLeft():\n    InertialSensor.set_heading(90,DEGREES)\n    SetWallstake(140)\n    turnTo(134)\n    forward(180,slow = True)\n    turnTo(134)\n    WallStakeTo(1050)\n    forward(50)\n    returning = Thread(WallStakePrep)\n    turnTo(135)\n    backward(500)\n    pause(0.3)\n    turnTo(90)\n    LiftLifter()\n    Loader.spin(FORWARD)\n    storing = Thread(StoreRing)\n    turnTo(90)\n    forward(400)\n    pause(0.1)\n    LowerLifter()\n    pause(0.1)\n    turnTo(147)\n    backward(300)\n    Loader.spin(REVERSE)\n    backward(450,slow = True)\n    clampMogo()\n    Belt.spin(FORWARD)\n    pause(0.5)\n    turnTo(275)\n    startIntake()\n    forward(625)\n    pause(0.2)\n    turnTo(70)\n    forward(650)\n    forward(100,slow = True)\n\ndef RedRight():\n    InertialSensor.set_heading(90,DEGREES)\n    \n    turnTo(46)\n    forward(180,slow = True)\n    turnTo(46)\n    WallStakeTo(163,actual = True)\n    forward(70)\n    returning = Thread(WallStakePrep)\n    turnTo(45)\n    backward(520)\n    pause(0.3)\n    turnTo(90)\n    LiftLifter()\n    Loader.spin(FORWARD)\n    storing = Thread(StoreRing)\n    Loader.spin(FORWARD)\n    turnTo(90)\n    forward(400)\n    pause(0.1)\n    LowerLifter()\n    pause(0.1)\n    turnTo(33)\n    backward(300)\n    turnTo(35)\n    backward(450,slow = True)\n    clampMogo()\n    Loader.spin(FORWARD)\n    Belt.spin(FORWARD)\n    pause(0.5)\n    turnTo(270)\n    Loader.spin(FORWARD)\n    startIntake()\n    forward(625)\n    pause(0.2)\n    turnTo(100)\n    Loader.spin(FORWARD)\n    turnTo(105)\n    forward(650)\n\ndef BlueLeft():\n    InertialSensor.set_heading(90,DEGREES)\n    SetWallstake(140)\n    turnTo(134)\n    forward(180,slow = True)\n    turnTo(134)\n    WallStakeTo(1050)\n    forward(50)\n    returning = Thread(WallStakePrep)\n    turnTo(135)\n    backward(500)\n    pause(0.3)\n    turnTo(90)\n    LiftLifter()\n    Loader.spin(FORWARD)\n    storing = Thread(StoreRing)\n    turnTo(90)\n    forward(400)\n    pause(0.1)\n    LowerLifter()\n    pause(0.1)\n    turnTo(147)\n    backward(300)\n    Loader.spin(REVERSE)\n    backward(450,slow = True)\n    clampMogo()\n    Belt.spin(FORWARD)\n    pause(0.5)\n    turnTo(275)\n    startIntake()\n    forward(625)\n    pause(0.2)\n    turnTo(70)\n    forward(650)\n    forward(100,slow = True)\n\ndef BlueRight():\n    InertialSensor.set_heading(90,DEGREES)\n    SetWallstake(140)\n    turnTo(46)\n    forward(180,slow = True)\n    turnTo(46)\n    WallStakeTo(1050)\n    forward(50)\n    returning = Thread(WallStakePrep)\n    turnTo(45)\n    backward(500)\n    pause(0.3)\n    turnTo(90)\n    LiftLifter()\n    Loader.spin(FORWARD)\n    storing = Thread(StoreRing)\n    turnTo(90)\n    forward(400)\n    pause(0.1)\n    LowerLifter()\n    pause(0.1)\n    turnTo(33)\n    backward(300)\n    Loader.spin(REVERSE)\n    backward(450,slow = True)\n    clampMogo()\n    Belt.spin(FORWARD)\n    pause(0.5)\n    turnTo(265)\n    startIntake()\n    forward(625)\n    pause(0.2)\n    turnTo(110)\n    forward(650)\n    forward(100,slow = True)\n\ndef bit():\n    for motor in RightMotors:\n        motor.set_velocity(80,PERCENT)\n    for motor in LeftMotors:\n        motor.set_velocity(80,PERCENT)\n    for motor in DriveMotors:\n        motor.spin(FORWARD)\n\n    count = 0\n\n    while count < 850:\n        wait(1,MSEC)\n        count += 1\n    for motor in RightMotors:\n        motor.set_velocity(0,PERCENT)\n    for motor in LeftMotors:\n        motor.set_velocity(40,PERCENT)\n\ndef curve():\n    count = 0\n    while count < 200:\n        wait(1,MSEC)\n        count += 1\n    for motor in DriveMotors:\n        motor.stop()\n    \n\ndef RedRingRush():\n    Loader.spin(FORWARD)\n    forward(900)\n    turnTo(320)\n    turnTo(320)\n    forward(200)\n    backward(200)\n    turnTo(305)\n    backward(450, slow = True)\n    clampMogo()\n    Belt.spin(FORWARD)\n    turnTo(105)\n    forward(600)\n    turnTo(135)\n    forward(825)\n    LiftLifter()\n    turnTo(90)\n    forward(200)\n    turnTo(90)\n    forward(550)\n\ndef BlueRingRush():\n\n    Loader.spin(FORWARD)\n    forward(900)\n    turnTo(40)\n    turnTo(40)\n    forward(200)\n    backward(200)\n    turnTo(55)\n    backward(450, slow = True)\n    clampMogo()\n    Belt.spin(FORWARD)\n    turnTo(75)\n    forward(600)\n    turnTo(225)\n    forward(825)\n    LiftLifter()\n    turnTo(270)\n    forward(200)\n    turnTo(270)\n    forward(550)\n\n\ndef Autonomous():\n    global ColourSort\n    ColourSort = False\n    AutonChoosing()\n    for motor in  DriveMotors:\n        motor.set_stopping(HOLD)\n    display(7,AutonOptions[SelectedAuton-1] + \"Starting\")\n    if SelectedAuton == 1:\n        RedLeft()\n    elif SelectedAuton == 2:\n        RedRight()\n    elif SelectedAuton == 3:\n        BlueLeft()\n    elif SelectedAuton == 4:\n        BlueRight()\n    elif SelectedAuton == 5:\n        RedRingRush()\n    else:\n        BlueRingRush()\n    ColourSort = True\n\ndef Driver():\n    global SpeedMultiplier\n    SpeedMultiplier = 1\n    for motor in DriveMotors:\n        motor.set_stopping(COAST)\n\ndef CalibrateWallStake():\n    d = 0\n    SetWallstake(d)\n\ndef MotorTemp():\n    x = 0\n    for motor in DriveMotors:\n        message = str(x+1) + ': '+str(motor.temperature(PERCENT))\n        row = x//2+1\n        if x % 2 == 0:\n            val = 1\n            controller_1.screen.clear_row(row)\n            controller_2.screen.clear_row(row)\n        else:\n            val = 10\n        \n        controller_1.screen.set_cursor(row,val)\n        controller_1.screen.print(message)\n        controller_2.screen.set_cursor(row,val)\n        controller_2.screen.print(message)\n        \n        if x == 1:\n            controller_1.screen.set_cursor(1,20)\n            controller_1.screen.print(str(brain.battery.capacity()) + '%')\n            controller_2.screen.set_cursor(1,20)\n            controller_2.screen.print(str(brain.battery.capacity()) + '%')\n        elif x == 3:\n            controller_1.screen.set_cursor(2,20)\n            controller_1.screen.print(NumberToCode(SelectedAuton))\n            controller_2.screen.set_cursor(2,20)\n            controller_2.screen.print(NumberToCode(SelectedAuton))\n        elif x== 5:\n            controller_1.screen.set_cursor(3,20)\n            controller_1.screen.print(\"1\")\n            controller_2.screen.set_cursor(3,20)\n            controller_2.screen.print(\"2\")\n        x += 1\n\ndef NumberToCode(Number):\n    return AutonShort[SelectedAuton-1]\n\ndef StartProcedure():\n    global SpeedLeft, SpeedRight, ColourSort\n    brain.screen.clear_screen()\n    brain.screen.print(\"T-VEX\")\n    brain.screen.next_row()\n    brain.screen.print(\"CyberSquad_78116A\")\n    brain.screen.next_row()\n    brain.screen.print(\"A Bajaj & Collis production\")\n    Belt.set_velocity(60, PERCENT)\n    Belt.set_max_torque(100,PERCENT)\n    Loader.set_velocity(100, PERCENT)\n    WallStakeMotor.set_velocity(100, PERCENT)\n    WallStakeMotor.set_stopping(HOLD)\n    CalibrateWallStake()\n    InertialCalibration()\n    StartTime = time.time()\n    AutonChoosing()\n    #Autonomous()\n    Stop = False\n    while True:\n        if not competition.is_autonomous() and not Stop:\n            AutonChoosing()\n            if (time.time() - StartTime >= 10) or brain.screen.pressing():\n                Stop = True\n                print('Auton Selector disabled')\n        if competition.is_driver_control():\n            ColourSort = True\n            SpeedLeft = (controller_1.axis3.position()) / 8.3\n            SpeedRight = (controller_1.axis2.position()) / 8.3\n            L1.spin(FORWARD, SpeedLeft, VOLT)\n            L2.spin(FORWARD, SpeedLeft, VOLT)\n            L3.spin(FORWARD, SpeedLeft, VOLT)\n            R1.spin(FORWARD, SpeedRight, VOLT)\n            R2.spin(FORWARD, SpeedRight, VOLT)\n            R3.spin(FORWARD, SpeedRight, VOLT)\n        wait(5,MSEC)\n    \ndef clampMogo():\n    Mogo.set(True)\n\ndef unclampMogo():\n    Mogo.set(False)\n    Belt.spin_for(REVERSE,20,DEGREES)\n\ndef LoaderToggle():\n    global loaderEnabled, beltChecker\n    if loaderEnabled:\n        Belt.stop()\n        Loader.spin(FORWARD)\n    else:\n        Loader.stop()\n    loaderEnabled = not(loaderEnabled)\n    beltChecker = False\n    \ndef startIntake():\n    global beltChecker\n    beltChecker = True\n    Belt.spin(FORWARD)\n    Loader.spin(FORWARD)\n\ndef reverseIntake():\n    global beltChecker\n    Belt.spin(REVERSE)\n    Loader.spin(REVERSE)\n    beltChecker = False\n\ndef stopIntake():\n    global beltChecker\n    Belt.stop()\n    Loader.stop()\n    beltChecker = False\n\ndef LiftLifter():\n    lifter.set(True)\n\ndef LowerLifter():\n    lifter.set(False)\n\ndef ToggleLifter():\n    global lifterEnabled\n    lifter.set(not(lifterEnabled))\n    lifterEnabled = not(lifterEnabled)\n\ndef LiftArm():\n    Arm.set(True)\n\ndef LowerArm():\n    Arm.set(False)\n\ndef ToggleArm():\n    global armEnabled\n    Arm.set(not(armEnabled))\n    armEnabled = not(armEnabled)\n\ndef WallStakeUp():\n    global wallStakeLoading, buttonLoop\n    wallStakeLoading = False\n    buttonLoop = False\n    WallStakeMotor.spin(FORWARD)\n\n\ndef WallStakeDown():\n    global wallStakeLoading, buttonLoop\n    wallStakeLoading = False\n    buttonLoop = False\n    WallStakeMotor.spin(REVERSE)\n\ndef WallStakeStop():\n    WallStakeMotor.stop()\n\ndef PlaceWallStake():\n    global ColourSort\n    ColourSort = False\n    Belt.stop()\n    WallStakeTo(700)\n    WallStakeTo(300)\n    ColourSort = True\n\ndef WallStakePosition():\n    return WallstakeRotation.position(DEGREES) + int(WallstakeRotation.position(TURNS)) * 360\n\ndef WallStakeTo(pos,speed = 80,actual = False):\n    if not actual:\n        pos = pos / 5\n    for _ in range(2):\n        WallStakeMovement(pos,speed = speed)\n\ndef WallStakeMovement(pos, speed = 80):\n    global wallStakeLoading\n    wallStakeLoading = False\n    WallStakeMotor.set_velocity(speed,PERCENT)\n    val = WallStakePosition()\n    diff = abs(val-pos)\n    last = pos\n    count = 0\n    speed = 100\n    limit = 800\n    while abs(val-pos) > 0.5 and count < (limit*diff):\n        if abs(val-pos) < 20:\n            WallStakeMotor.set_velocity(40,PERCENT)\n        elif abs(val-pos) < 5:\n            WallStakeMotor.set_velocity(20,PERCENT)\n        elif abs(val-pos) < 1:\n            WallStakeMotor.set_velocity(15,PERCENT)\n            \n        if val > pos:\n            WallStakeDown()\n        else:\n            WallStakeUp()\n        count += 1\n        last = val\n        wait(0.1,MSEC)\n        val = WallStakePosition()\n\n    \n        \n    WallStakeStop()\n    if count == limit*diff:\n        print('Wallstake didn\\'t reach target',pos)\n\n    WallStakeMotor.set_velocity(100,PERCENT)\n\n\ndef WallStakeLow():\n    global wallStakeLoading, beltChecker, buttonLoop\n    wallStakeLoading = False\n    buttonLoop = True\n    while buttonLoop and not(ResetButton.pressing()):\n        WallStakeMotor.spin(REVERSE)\n    WallStakeMotor.stop()\n    buttonLoop = False\n    startIntake()\n\ndef WallStakeHigh():\n    global wallStakeLoading, beltChecker, buttonLoop\n    buttonLoop = False\n    if WallStakePosition() > 150:\n        WallStakeLow()\n    WallStakeTo(14,actual = True)\n    wallStakeLoading = True\n    beltChecker = False\n    startIntake()\n\ndef AutonChoosing():\n    global SelectedAuton, AvoidBlue, LastAuton\n    value = AutonSelector.angle(DEGREES)\n    total = 330\n\n    autonNum = len(AutonOptions)\n    for x in range(autonNum):\n        if value <= total / autonNum * x:\n            SelectedAuton = x+1\n            break\n\n    AvoidBlue = (AutonOptions[SelectedAuton-1][0:3] == \"Red\")\n    if SelectedAuton != LastAuton:\n        display(6,AutonOptions[SelectedAuton-1] + \" Selected\")\n        controller_1.screen.set_cursor(2,20)\n        controller_1.screen.print(NumberToCode(SelectedAuton))\n        controller_2.screen.set_cursor(2,20)\n        controller_2.screen.print(NumberToCode(SelectedAuton))\n    LastAuton = SelectedAuton\n\ndef WallStakeAvoid():\n    WallStakeTo(50,actual = True)\n\ndef ColourSorting():\n    global AvoidBlue\n    ColourSensor.set_light(LedStateType.ON)\n    while True:\n        if ColourSort:\n            if AvoidBlue:\n                Avoid = Color.BLUE\n            else:\n                Avoid = Color.RED\n            if ColourSensor.color() == Avoid:\n                print('Spotted')\n                pause(0.1)\n                Belt.set_velocity(40,PERCENT)\n                previousPos = WallStakePosition()\n                if previousPos < 50:\n                    if previousPos < 10:\n                        concurrent = Thread(WallStakeLow)\n                    else:\n                        concurrent = Thread(WallStakeAvoid)\n                pause(0.25)\n                while DistanceSensor.object_distance(MM) >= 25:\n                    wait(2,MSEC)\n                Belt.set_velocity(100, PERCENT)\n                Belt.spin_for(FORWARD, 122,DEGREES)\n                stopIntake()\n                Belt.spin_for(REVERSE,5,DEGREES)\n                pause(0.5)\n                startIntake()\n                Belt.set_velocity(60,PERCENT)\n                moving = Thread(WallStakeTo(previousPos,actual = True))\n        \n        wait(10,MSEC)\n    \ndef StakeLoader():\n    global beltChecker, wallStakeLoading\n    while True:\n        if wallStakeLoading:\n            beltChecker = False\n            while DistanceSensor.object_distance(MM) >= 25:\n                wait(60,MSEC)\n            while Belt.velocity() > 0.1:\n                pause(0.5)\n            Belt.stop()\n            wallStakeLoading = False\n        wait(10,MSEC)\n\ndef InertialCalibration():\n    InertialSensor.calibrate()\n    while InertialSensor.is_calibrating():\n        wait(100, MSEC)\n\ndef RunAuton():\n    autonTask = Thread(Autonomous)\n    while(competition.is_autonomous() and competition.is_enabled()):\n        wait(10, MSEC)\n    autonTask.stop()\n\ndef RunDriver():\n    global ColourSort\n    driverTask = Thread(Driver)\n    ColourSort = True\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        wait( 10, MSEC )\n    driverTask.stop()\n\ndef DisplayTemp():\n    AutonChoosing()\n    while True:\n        MotorTemp()\n        pause(5)\n\ndef BeltUnstucker():\n    while True:\n        if beltChecker:\n            pause(1)\n            while beltChecker:\n                if Belt.velocity() < 0.1:\n                    Belt.spin_for(REVERSE,59,DEGREES)\n                    Belt.spin(FORWARD)\n                pause(0.1)\n        wait(10,MSEC)\n            \ndef ResetPosition():\n    while True:\n        if ResetButton.pressing():\n            SetWallstake(0)\n            while ResetButton.pressing():\n                wait(1,MSEC)\n        wait(10,MSEC)\n\ncompetition = Competition( RunDriver, RunAuton )\n\ncontroller_1.buttonR1.pressed(clampMogo)\ncontroller_1.buttonR2.pressed(unclampMogo)\ncontroller_1.buttonL1.pressed(startIntake)\ncontroller_1.buttonL2.pressed(reverseIntake)\ncontroller_1.buttonL2.released(stopIntake)\ncontroller_1.buttonX.released(ToggleArm)\ncontroller_1.buttonY.released(ToggleLifter)\ncontroller_1.buttonA.released(PlaceWallStake)\ncontroller_1.buttonB.released(LoaderToggle)\ncontroller_1.buttonUp.released(WallStakeHigh)\ncontroller_1.buttonDown.released(WallStakeLow)\ncontroller_1.buttonLeft.pressed(WallStakeDown)\ncontroller_1.buttonLeft.released(WallStakeStop)\ncontroller_1.buttonRight.pressed(WallStakeUp)\ncontroller_1.buttonRight.released(WallStakeStop)\n\ncontroller_2.buttonR1.pressed(clampMogo)\ncontroller_2.buttonR2.pressed(unclampMogo)\ncontroller_2.buttonL1.pressed(startIntake)\ncontroller_2.buttonL2.pressed(reverseIntake)\ncontroller_2.buttonL2.released(stopIntake)\ncontroller_2.buttonX.released(ToggleArm)\ncontroller_2.buttonY.released(ToggleLifter)\ncontroller_2.buttonA.released(PlaceWallStake)\ncontroller_2.buttonB.released(LoaderToggle)\ncontroller_2.buttonUp.released(WallStakeHigh)\ncontroller_2.buttonDown.released(WallStakeLow)\ncontroller_2.buttonLeft.pressed(WallStakeDown)\ncontroller_2.buttonLeft.released(WallStakeStop)\ncontroller_2.buttonRight.pressed(WallStakeUp)\ncontroller_2.buttonRight.released(WallStakeStop)\n\nwait(15,MSEC)\n\nsimulRun1 = Thread(ColourSorting)\nsimulRun2 = Thread(DisplayTemp)\nsimulRun3 = Thread(BeltUnstucker)\nsimulRun4 = Thread(ResetPosition)\nsimulRun5 = Thread(StakeLoader)\nStartProcedure()\n","textLanguage":"python","robotConfig":[{"port":[1],"name":"L1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"L2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"R1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"R2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[9],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"Mogo","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[20],"name":"Belt","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"Loader","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"expander_4","customName":false,"deviceType":"Expander","deviceClass":"triport","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"lifter","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[3],"name":"Arm","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[5],"name":"WallStakeMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[2],"name":"AutonSelector","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{"id":"partner"},"triportSourcePort":22},{"port":[19],"name":"ColourSensor","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{"id":"partner"},"triportSourcePort":22},{"port":[10],"name":"DistanceSensor","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[18],"name":"InertialSensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[],"name":"controller_2","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"partner"},"triportSourcePort":22},{"port":[8],"name":"ResetButton","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{"id":"partner"},"triportSourcePort":4},{"port":[15],"name":"WallstakeRotation","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}