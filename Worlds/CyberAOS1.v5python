{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nexpander_4 = Triport(Ports.PORT4)\nL1 = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nL2 = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nL3 = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nR1 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, True)\nR2 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\nR3 = Motor(Ports.PORT9, GearSetting.RATIO_6_1, True)\ncontroller_1 = Controller(PRIMARY)\nMogo = DigitalOut(brain.three_wire_port.h)\nBelt = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nLoader = Motor(Ports.PORT17, GearSetting.RATIO_18_1, True)\nlifter = DigitalOut(expander_4.a)\nArm = DigitalOut(expander_4.c)\nWallStakeMotor = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nAutonSelector = PotentiometerV2(brain.three_wire_port.b)\nColourSensor = Optical(Ports.PORT19)\nDistanceSensor = Distance(Ports.PORT10)\nInertialSensor = Inertial(Ports.PORT18)\ncontroller_2 = Controller(PARTNER)\nResetButton = Limit(expander_4.f)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nimport time \n\nSpeedLeft = 0\nSpeedRight = 0\nSpeedMultiplier = 1\nWheelDiameter = 82.55\nWheelBaseWidth = 254\nPi = 3.1415\nkp = 0.12\nki = 0\nkd = 0.15\nLeftMotors = [L1,L2,L3]\nRightMotors = [R1,R2,R3]\nDriveMotors = LeftMotors + RightMotors\narmEnabled = False\nlifterEnabled = False\nloaderEnabled = False\nwallStakeLoading = False\nbeltChecker = False\nLastAuton = ''\nButtonLoop = False\n\ndef pause(sec):\n    wait(sec,SECONDS)\n\ndef PIDControl(target, isTurning=False, reverse = False,slow=False,bad = False):\n\n    if not slow:\n        highest = 90\n        lowest = -90\n    else:\n        highest = 35\n        lowest = -35\n\n    integral = 0\n    lastError = 0\n\n    if isTurning:\n        kp = 0.56\n        kd = 1.24\n        threshold = 0.6\n    else:\n        kp = 0.12\n        kd = 0.25\n        threshold = 3\n    error = threshold + 1\n\n    for motor in DriveMotors:\n        motor.reset_position()\n    count = 300\n    passed = False\n    direction = ''\n\n    while count > 0 and abs(error) > threshold:\n        if isTurning:\n            current = InertialSensor.heading() \n            error = (target-current+540)%360-180\n            if bad and not passed:\n                if error < 0:\n                    error += 360\n                else:\n                    error -= 360\n                if direction == '':\n                    direction = error / abs(error)\n                else:\n                    if error / abs(error) != direction:\n                        passed = True\n                        if error < 0:\n                            error += 360\n                        else:\n                            error -= 360\n        else:\n            leftPos = sum([m.position(DEGREES) for m in [L1, L2, L3]]) / 3\n            rightPos = sum([m.position(DEGREES) for m in [R1, R2, R3]]) / 3\n            current = (abs(leftPos) + abs(rightPos)) / 2  \n            error = target-current         \n\n        integral += error\n        derivative = error - lastError\n\n        power = (kp * error) + (ki * integral) + (kd * derivative)\n        power = max(min(power, highest), lowest)\n        power *= SpeedMultiplier\n        if isTurning:\n            if power < 0:\n                power = abs(power)\n                for motor in LeftMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n            else:\n                for motor in LeftMotors:\n                    motor.spin(FORWARD, power, PERCENT)\n                for motor in RightMotors:\n                    motor.spin(REVERSE, power, PERCENT)\n        else:\n            for motor in DriveMotors:\n                if reverse:\n                    motor.spin(REVERSE, power, PERCENT)\n                else:\n                    motor.spin(FORWARD,power,PERCENT)\n        count -= 1\n        lastError = error\n        \n        wait(10, MSEC)\n\n    print(current, target)\n    for motor in DriveMotors:\n        motor.stop()\n    if count == 0:\n        print('Didn\\'t reach target')\n\ndef distanceToDegrees(dist):\n    degrees = (dist / (WheelDiameter * Pi)) * 360\n    degrees *= (4/3)\n    return degrees\n\n\n\ndef forward(dist, slow=False):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees, slow=slow)\n\ndef backward(dist, slow=False):\n    degrees = distanceToDegrees(dist)\n    PIDControl(degrees, reverse=True, slow=slow)\n\ndef turnTo(target,PID = False, bad = False):\n    target = target % 360\n    PIDControl(target, isTurning=True, bad = bad)\n    PIDControl(target, isTurning=True)\n    print(InertialSensor.heading(DEGREES))\n\ndef display(row,message):\n    brain.screen.set_cursor(row,6)\n    brain.screen.clear_row(row)\n    brain.screen.print(message)\n\ndef ReturnWallstake():\n    while not(ResetButton.pressing()):\n        WallStakeMotor.spin(REVERSE)\n        wait(10,MSEC)\n    WallStakeMotor.stop()\n\ndef CornerOne():\n    InertialSensor.set_heading(0,DEGREES)\n\n    # Place WallStake Ring\n\n    Belt.spin(FORWARD)\n    pause(0.5)\n    Belt.stop()\n\n    # Clamp Mogo\n    forward(350)\n    turnTo(270)\n    backward(500,slow = True)\n    clampMogo()\n    backward(50)\n\n    # Fill Stake \n\n    turnTo(5)\n    turnTo(0)\n    startIntake()\n    forward(600)\n    turnTo(130)\n    forward(400)\n    turnTo(130)\n    forward(400)\n    turnTo(180)\n    forward(300)\n    backward(50)\n\n    # Place Stake\n    #turnTo(10)\n    turnTo(300,bad = True)\n    backward(250)\n    unclampMogo()\n    stopIntake()\n    Loader.spin(FORWARD)\n\ndef CornerTwo():\n\n    forward(360)\n    turnTo(96)\n    turnTo(96)\n    backward(300)\n    turnTo(94)\n    backward(900)\n    backward(500,slow = True)\n    clampMogo()\n    startIntake()\n    turnTo(0)\n\n    # Fill Stake \n\n    turnTo(5)\n    startIntake()\n    forward(600)\n    turnTo(214)\n    forward(800)\n    turnTo(180)\n    forward(250)\n    backward(100)\n\n    # Place Stake\n    #turnTo(250)\n    turnTo(60,bad = True)\n    backward(280)\n    unclampMogo()\n\ndef StoreRing():\n    count = 200\n    while DistanceSensor.object_distance(MM) > 75 and count > 0:\n        Belt.spin(FORWARD)\n        count -= 1\n        wait(10,MSEC)\n    Belt.stop()\n\ndef CornerThree():\n\n    forward(250)\n    stopIntake()\n    Loader.spin(FORWARD)\n    turnTo(0)\n    pause(0.1)\n    turnTo(0)\n    Belt.spin(FORWARD)\n    storing = Thread(StoreRing)\n    driving = Thread(forward(2000))\n    pause(0.1)\n    Belt.stop()\n    Loader.spin(FORWARD)\n    turnTo(225)\n    backward(650)\n    turnTo(240)\n    backward(275)\n    turnTo(265)\n    backward(200)\n    backward(350, slow = True)\n    clampMogo()\n    turnTo(330)\n    backward(100)\n    pause(0.1)\n    Belt.spin(FORWARD)\n    pause(1.5)\n    Belt.stop()\n    Loader.stop()\n    unclampMogo()\n    turnTo(150)\n    backward(350)\n    clampMogo()\n    turnTo(94)\n    backward(700)\n    backward(570)\n   \n\ndef CornerFour():\n    forward(200)\n    turnTo(280)\n    backward(1000)\n    turnTo(265)\n    backward(1400)\n    upping = Thread(PlaceWallStake)\n    turnTo(48,bad = True)\n    backward(900)\n    backward(500,slow = True)\n\ndef Autonomous():\n    CornerOne()\n    CornerTwo()\n    CornerThree()\n    CornerFour()\n\ndef Driver():\n    global SpeedMultiplier\n    SpeedMultiplier = 1\n    for motor in DriveMotors:\n        motor.set_stopping(COAST)\n\ndef CalibrateWallStake():\n    d = 0\n    WallStakeMotor.set_position(d,DEGREES)\n\ndef MotorTemp():\n    x = 0\n    for motor in DriveMotors:\n        message = str(x+1) + ': '+str(motor.temperature(PERCENT))\n        row = x//2+1\n        if x % 2 == 0:\n            val = 1\n            controller_1.screen.clear_row(row)\n            controller_2.screen.clear_row(row)\n        else:\n            val = 10\n        \n        controller_1.screen.set_cursor(row,val)\n        controller_1.screen.print(message)\n        controller_2.screen.set_cursor(row,val)\n        controller_2.screen.print(message)\n        \n        if x == 1:\n            controller_1.screen.set_cursor(1,20)\n            controller_1.screen.print(str(brain.battery.capacity()) + '%')\n            controller_2.screen.set_cursor(1,20)\n            controller_2.screen.print(str(brain.battery.capacity()) + '%')\n        elif x == 3:\n            controller_1.screen.set_cursor(2,20)\n            controller_1.screen.print('AS')\n            controller_2.screen.set_cursor(2,20)\n            controller_2.screen.print('AS')\n        elif x== 5:\n            controller_1.screen.set_cursor(3,20)\n            controller_1.screen.print(\"1\")\n            controller_2.screen.set_cursor(3,20)\n            controller_2.screen.print(\"2\")\n        x += 1\n\ndef StartProcedure():\n    global SpeedLeft, SpeedRight\n    brain.screen.clear_screen()\n    brain.screen.print(\"T-VEX\")\n    brain.screen.next_row()\n    brain.screen.print(\"CyberSquad_78116A\")\n    brain.screen.next_row()\n    brain.screen.print(\"A Bajaj & Collis production\")\n    Belt.set_velocity(60, PERCENT)\n    Belt.set_max_torque(100,PERCENT)\n    Loader.set_velocity(100, PERCENT)\n    WallStakeMotor.set_velocity(100, PERCENT)\n    WallStakeMotor.set_stopping(HOLD)\n    CalibrateWallStake()\n    InertialCalibration()\n    TenSeconds = False\n    AutonChoosing()\n    #Autonomous()\n    while True:\n        if competition.is_driver_control():\n            SpeedLeft = (controller_1.axis3.position()) / 8.3\n            SpeedRight = (controller_1.axis2.position()) / 8.3\n            L1.spin(FORWARD, SpeedLeft, VOLT)\n            L2.spin(FORWARD, SpeedLeft, VOLT)\n            L3.spin(FORWARD, SpeedLeft, VOLT)\n            R1.spin(FORWARD, SpeedRight, VOLT)\n            R2.spin(FORWARD, SpeedRight, VOLT)\n            R3.spin(FORWARD, SpeedRight, VOLT)\n        wait(5,MSEC)\n    \ndef clampMogo():\n    Mogo.set(True)\n\ndef unclampMogo():\n    Mogo.set(False)\n    Belt.spin_for(REVERSE,20,DEGREES)\n\ndef LoaderToggle():\n    global loaderEnabled, beltChecker\n    if loaderEnabled:\n        Belt.stop()\n        Loader.spin(FORWARD)\n    else:\n        Loader.stop()\n    loaderEnabled = not(loaderEnabled)\n    beltChecker = False\n    \ndef startIntake():\n    global beltChecker\n    Belt.spin(FORWARD)\n    Loader.spin(FORWARD)\n    beltChecker = True\n\ndef reverseIntake():\n    global beltChecker\n    Belt.spin(REVERSE)\n    Loader.spin(REVERSE)\n    beltChecker = False\n\ndef stopIntake():\n    global beltChecker\n    beltChecker = False\n    Belt.stop()\n    Loader.stop()\n\ndef LiftLifter():\n    lifter.set(True)\n\ndef LowerLifter():\n    lifter.set(False)\n\ndef ToggleLifter():\n    global lifterEnabled\n    lifter.set(not(lifterEnabled))\n    lifterEnabled = not(lifterEnabled)\n\ndef LiftArm():\n    Arm.set(True)\n\ndef LowerArm():\n    Arm.set(False)\n\ndef ToggleArm():\n    global armEnabled\n    Arm.set(not(armEnabled))\n    armEnabled = not(armEnabled)\n\ndef WallStakeUp():\n    global buttonLoop\n    buttonLoop = False\n    WallStakeMotor.spin(FORWARD)\n\ndef WallStakeDown():\n    global buttonLoop\n    buttonLoop = False\n    WallStakeMotor.spin(REVERSE)\n\ndef WallStakeStop():\n    WallStakeMotor.stop()\n\ndef PlaceWallStake():\n    Belt.stop()\n    WallStakeTo(700)\n    WallStakeTo(300)\n\ndef WallStakePosition():\n    return int(WallStakeMotor.position(DEGREES))\n\ndef WallStakeTo(pos, speed = 80):\n    global wallStakeLoading\n    wallStakeLoading = False\n    WallStakeMotor.set_velocity(speed,PERCENT)\n    val = WallStakePosition()\n    diff = abs(val-pos)\n    last = pos\n    count = 0\n    speed = 100\n    while abs(val-pos) > 2 and count < (20*diff):\n        if abs(val-pos) < 50:\n            WallStakeMotor.set_velocity(40,PERCENT)\n        elif abs(val-pos) < 25:\n            WallStakeMotor.set_velocity(20,PERCENT)\n            \n        if val > pos:\n            WallStakeDown()\n        else:\n            WallStakeUp()\n        if val == last:\n            count += 1\n        else:\n            count = 0\n        last = val\n        wait(0.1,MSEC)\n        val = WallStakePosition()\n        \n    WallStakeStop()\n    if count == 20*diff:\n        print('Wallstake didn\\'t reach target',pos)\n    WallStakeMotor.set_velocity(100,PERCENT)\n\n\ndef WallStakeLow():\n    global beltChecker, buttonLoop\n    buttonLoop = True\n    while buttonLoop and not(ResetButton.pressing()):\n        WallStakeMotor.spin(REVERSE)\n    WallStakeMotor.stop()\n    buttonLoop = False\n    Belt.spin(FORWARD)\n    beltChecker = True\n\ndef WallStakeHigh():\n    global wallStakeLoading, beltChecker, buttonLoop\n    buttonLoop = False\n    WallStakeTo(92)\n    wallStakeLoading = True\n    beltChecker = False\n\ndef AutonChoosing():\n    display(6, 'Auton Skills Selected')\n    controller_1.screen.set_cursor(2,20)\n    controller_1.screen.print('AS')\n    controller_2.screen.set_cursor(2,20)\n    controller_2.screen.print('AS')\n\ndef ColourSorting():\n    global AvoidBlue\n    ColourSensor.set_light(LedStateType.ON)\n    while True:\n        if ColourSensor.color() == Color.BLUE:\n            Belt.set_velocity(40,PERCENT)\n            previousPos = WallStakePosition()\n            if previousPos < 320:\n                concurrent = Thread(WallStakeLow)\n            pause(0.25)\n            while DistanceSensor.object_distance(MM) >= 25:\n                wait(2,MSEC)\n            Belt.spin_for(FORWARD, 120,DEGREES)\n            Belt.stop()\n            wait(20,MSEC)\n            Belt.set_velocity(60, PERCENT)\n            Belt.spin(FORWARD)\n            WallStakeTo(previousPos)\n        wait(10,MSEC)\n\n\ndef ObjectDetected():\n    global beltChecker\n    if wallStakeLoading:\n        beltChecker = False\n        while DistanceSensor.object_distance(MM) >= 25:\n            wait(60,MSEC)\n        while Belt.velocity() > 0.1:\n            pause(0.5)\n        Belt.spin_for(REVERSE,20,DEGREES)\n        WallStakeTo(200)\n        beltChecker = True\n\ndef InertialCalibration():\n    InertialSensor.calibrate()\n    while InertialSensor.is_calibrating():\n        wait(100, MSEC)\n\ndef RunAuton():\n    autonTask = Thread(Autonomous)\n    while(competition.is_autonomous() and competition.is_enabled()):\n        wait(10, MSEC)\n    autonTask.stop()\n\ndef RunDriver():\n    driverTask = Thread(Driver)\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        wait( 10, MSEC )\n    driverTask.stop()\n\ndef DisplayTemp():\n    while True:\n        MotorTemp()\n        pause(5)\n\ndef BeltUnstucker():\n    while True:\n        if beltChecker:\n            pause(1)\n            while beltChecker:\n                if Belt.velocity() < 0.1:\n                    Belt.spin_for(REVERSE,59,DEGREES)\n                    Belt.spin(FORWARD)\n                pause(0.1)\n            Belt.stop()\n        wait(10,MSEC)\n            \ndef ResetPosition():\n    while True:\n        if ResetButton.pressing():\n            WallStakeMotor.set_position(0,DEGREES)\n            print('Reset To 0')\n            pause(0.5)\n        wait(10,MSEC)\n\ncompetition = Competition( RunDriver, RunAuton )\n\ncontroller_1.buttonR1.pressed(clampMogo)\ncontroller_1.buttonR2.pressed(unclampMogo)\ncontroller_1.buttonL1.pressed(startIntake)\ncontroller_1.buttonL2.pressed(reverseIntake)\ncontroller_1.buttonL2.released(stopIntake)\ncontroller_1.buttonX.released(ToggleArm)\ncontroller_1.buttonY.released(ToggleLifter)\ncontroller_1.buttonA.released(PlaceWallStake)\ncontroller_1.buttonB.released(LoaderToggle)\ncontroller_1.buttonUp.released(WallStakeHigh)\ncontroller_1.buttonDown.released(WallStakeLow)\ncontroller_1.buttonLeft.pressed(WallStakeDown)\ncontroller_1.buttonLeft.released(WallStakeStop)\ncontroller_1.buttonRight.pressed(WallStakeUp)\ncontroller_1.buttonRight.released(WallStakeStop)\n\ncontroller_2.buttonR1.pressed(clampMogo)\ncontroller_2.buttonR2.pressed(unclampMogo)\ncontroller_2.buttonL1.pressed(startIntake)\ncontroller_2.buttonL2.pressed(reverseIntake)\ncontroller_2.buttonL2.released(stopIntake)\ncontroller_2.buttonX.released(ToggleArm)\ncontroller_2.buttonY.released(ToggleLifter)\ncontroller_2.buttonA.released(PlaceWallStake)\ncontroller_2.buttonB.released(LoaderToggle)\ncontroller_2.buttonUp.released(WallStakeHigh)\ncontroller_2.buttonDown.released(WallStakeLow)\ncontroller_2.buttonLeft.pressed(WallStakeDown)\ncontroller_2.buttonLeft.released(WallStakeStop)\ncontroller_2.buttonRight.pressed(WallStakeUp)\ncontroller_2.buttonRight.released(WallStakeStop)\n\nColourSensor.object_detected(ObjectDetected)\nwait(15,MSEC)\n\nsimulRun1 = Thread(ColourSorting)\nsimulRun2 = Thread(DisplayTemp)\nsimulRun3 = Thread(BeltUnstucker)\nsimulRun4 = Thread(ResetPosition)\nStartProcedure()","textLanguage":"python","robotConfig":[{"port":[1],"name":"L1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"L2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"R1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"R2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[9],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"Mogo","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[20],"name":"Belt","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"Loader","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"expander_4","customName":false,"deviceType":"Expander","deviceClass":"triport","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"lifter","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[3],"name":"Arm","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":4},{"port":[5],"name":"WallStakeMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[2],"name":"AutonSelector","customName":true,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{"id":"partner"},"triportSourcePort":22},{"port":[19],"name":"ColourSensor","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{"id":"partner"},"triportSourcePort":22},{"port":[10],"name":"DistanceSensor","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[18],"name":"InertialSensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[],"name":"controller_2","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"partner"},"triportSourcePort":22},{"port":[6],"name":"ResetButton","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":4}],"slot":1,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}